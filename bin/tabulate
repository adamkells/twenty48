#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/twenty_48'

include Twenty48

puts %w(
  board_size max_exponent max_resolve_depth start_states states
  mean_successor_states median_successor_states max_successor_states
  bz2_size mean_start_state_value
).join(',')

def count_successor_states(hash_model)
  hash_model.map do |_state0, actions|
    actions.map do |_action, successors|
      successors.size
    end.inject(&:+)
  end
end

def median(data)
  midpoint = data.size / 2
  sorted_data = data.sort
  if data.size.even?
    (sorted_data[midpoint] + sorted_data[midpoint + 1]) / 2.0
  else
    sorted_data[midpoint]
  end
end

Dir.glob(Storage::SOLVERS_GLOB).sort.each do |solver_pathname|
  solver_params = Storage.solver_params_from_pathname(solver_pathname)
  builder, resolver = Storage.new_builder_from_model_params(solver_params)
  solver = Storage.read_solver(solver_params)

  value = solver.value
  start_states = builder.start_states
  mean_start_state_value = start_states
    .map { |state| value[resolver.resolve(state)] }
    .inject(&:+) / start_states.size

  successor_state_counts = count_successor_states(solver.model.hash)

  puts [
    builder.board_size,
    builder.max_exponent,
    resolver.max_resolve_depth,
    value.size,
    successor_state_counts.inject(&:+) / successor_state_counts.size.to_f,
    median(successor_state_counts),
    successor_state_counts.max,
    File.stat(Storage.model_pathname(solver_params)).size,
    mean_start_state_value
  ].join(',')
end

# out of time / memory: at least 1446235 states
# tabulate(Builder.new(4, 4, true))
# out of patience: at least 5700 states
# Builder.new(4, 4, 3)
# out of patience: at least 88300 states
# Builder.new(4, 4, 2)
