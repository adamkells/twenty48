#!/usr/bin/env ruby
# frozen_string_literal: true

require 'csv'

require_relative '../lib/twenty48'

#
# We need something that we can easily load in a web browser that isn't too big.
# Try a very cheesy form of variable width encoding with deltas: write deltas
# as base-36 strings. Input is a `threshold-x.csv` file from bin/layer_tranche.
#
# Some tests on the 3x3 to 10 with threshold 1e-6 (sizes in bytes):
# 2279591 test.csv      - delta encoding in base 36
#  578692 test.csv.gz
# 5026612 test2.csv     - base 36 without delta encoding
# 1430601 test2.csv.gz
# 6639571 test3.csv     - hexadecimal without delta encoding
# 1508706 test3.csv.gz
#

#
# Pack data for browser.
#
class PackPolicyBin
  include Twenty48

  PolicyData = Struct.new(
    :action, :alternate_actions, :value
  ) do
    def packed_actions
      alternate_action_mask = 0
      offset = 0
      (0...4).each do |i|
        next if i == action
        alternate_action_mask |= 1 << offset if alternate_actions[i]
        offset += 1
      end
      action << 3 | alternate_action_mask
    end

    def rounded_value
      format('%.2f', value)
    end
  end

  def run
    data = Data.new(root: Data::ROOT)
    data.game.each do |game|
      next unless game.board_size == 2 && game.max_exponent == 4 ||
          game.board_size == 2 && game.max_exponent == 5 ||
          game.board_size == 3 && game.max_exponent == 9 ||
          game.board_size == 3 && game.max_exponent == 10 ||
          game.board_size == 4 && game.max_exponent == 6
      game.layer_model.each do |layer_model|
        next unless layer_model.max_depth == 0
        solutions = layer_model.part.first&.solution&.all || []
        solutions.each do |solution|
          next unless solution.alternate_action_tolerance > 0
          puts solution
          solution.tranche.each do |tranche|
            next unless tranche.threshold == 1e-6
            build(layer_model, solution, tranche)
          end
        end
      end
    end
  end

  def build(model, solution, tranche)
    packed_policy_csv = model.packed_policy_csv.new(
      solution.to_h.merge(tranche.to_h)
    )
    return if packed_policy_csv.exist?

    policy_data = read_policy_data(model, solution, tranche)
    packed_policy_data = pack_policy_data(policy_data)
    if tranche.alternate_actions
      write_packed_policy_with_alternate_actions(
        packed_policy_data, packed_policy_csv.to_s
      )
    else
      write_packed_policy(
        packed_policy_data, packed_policy_csv.to_s
      )
    end
    puts packed_policy_csv
  end

  def read_policy_data(model, solution, tranche)
    policy_data = {}
    model.part.each do |part|
      part_solution = part.solution.find_by(solution.to_h)
      next unless part_solution
      part_tranche = part_solution.tranche.find_by(tranche.to_h)
      next unless part_tranche

      part_tranche.each do |state, action, alternate_actions, value|
        policy_data[state.get_nybbles] =
          PolicyData.new(action, alternate_actions, value)
      end
    end
    policy_data
  end

  def pack_policy_data(policy_data)
    previous = 0
    policy_data.keys.sort.each_with_object([]) do |nybbles, result|
      delta = nybbles - previous
      raise "delta #{delta} too large for JS" if delta > 2**53 - 1
      result.push([delta, policy_data[nybbles]])
      previous = nybbles
    end
  end

  def write_packed_policy(packed_policy_data, pathname)
    CSV.open(pathname, 'w') do |csv|
      csv << %w[delta36 action value]
      packed_policy_data.each do |delta, data|
        csv << [
          delta.to_s(36), data.action, data.rounded_value
        ]
      end
    end
  end

  def write_packed_policy_with_alternate_actions(packed_policy_data, pathname)
    CSV.open(pathname, 'w') do |csv|
      csv << %w[delta36 actions36 value]
      packed_policy_data.each do |delta, data|
        csv << [
          delta.to_s(36), data.packed_actions.to_s(36), data.rounded_value
        ]
      end
    end
  end
end

PackPolicyBin.new.run
