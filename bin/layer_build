#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'

require_relative '../lib/twenty48'

include Twenty48

TOTAL_MEMORY = 8 * 1024**3
WORKING_MEMORY = (0.8 * TOTAL_MEMORY).ceil

def build(board_size:, max_exponent:, max_depth:, max_states:)
  # Note: exact discount value doesn't matter for build step.
  discount = 0.95

  states_path = Storage.layer_states_pathname(
    board_size: board_size,
    max_exponent: max_exponent,
    max_depth: max_depth
  )
  puts states_path
  if Dir.exist?(states_path)
    puts 'exists; skipping'
    return
  end
  FileUtils.mkdir_p states_path

  batch_size = LayerBuilder.find_states_per_batch(max_states)

  valuer = NativeValuer.create(
    board_size: board_size,
    max_exponent: max_exponent,
    max_depth: max_depth,
    discount: discount
  )
  layer_builder = LayerBuilder.new(board_size, states_path, max_states, valuer,
    verbose: true)
  layer_builder.build_start_state_layers
  layer_builder.build batch_size
end

#
# 2x2
#
(3..7).each do |max_exponent|
  (0..[3, max_exponent - 1].min).each do |max_depth|
    build(
      board_size: 2,
      max_exponent: max_exponent,
      max_depth: max_depth,
      max_states: 1024
    )
  end
end

#
# 3x3
#
(3..10).each do |max_exponent|
  (0..[1, max_exponent - 1].min).each do |max_depth|
    build(
      board_size: 3,
      max_exponent: max_exponent,
      max_depth: max_depth,
      max_states: 100_000
    )
  end
end

# build(
#   board_size: 4,
#   max_exponent: 11,
#   max_lose_depth: 0,
#   max_win_depth: 0,
#   max_states: LayerBuilder.find_max_successor_states(WORKING_MEMORY)
# )
