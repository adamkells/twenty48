#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative '../lib/twenty48'

max_states = 1000

include Twenty48

def node_name(state)
  "s#{state.to_a.join('_')}"
end

# rubocop:disable Metrics/AbcSize, Metrics/MethodLength
def build_graph(builder, resolver, solver)
  graph = Graph.new

  board_digits = [Math.log10(builder.max_exponent**2).ceil.to_i, 2].max
  start_states = builder.start_states
  model = solver.model
  policy = solver.policy
  value = solver.value

  policy.keys.sort.each do |state|
    optimal_action = policy[state]
    formatted_value = format('%.2f', value[state])

    cluster_name = format('%04d', state.sum) unless
      state.lose? || state.win?(builder.max_exponent)
    node_properties = graph.add_node(node_name(state), cluster_name)
    node_properties[:shape] = :record

    if state.win?(builder.max_exponent)
      node_properties[:color] = :blue
      node_properties[:label] = "{{win!}|{#{formatted_value}}}"
    elsif state.lose?
      node_properties[:color] = :red
      node_properties[:label] = "{{lose}|{#{formatted_value}}}"
    else
      node_properties[:color] = :green if start_states.member?(state)
      node_properties[:color] = :red if resolver.lose_state == state
      node_properties[:color] = :blue if resolver.win_states.member?(state)

      label_values = state.to_a.map do |cell_value|
        if cell_value.positive?
          string_value = format("%#{board_digits}d", 2**cell_value)
        else
          string_value = ' ' * board_digits
        end
        string_value.gsub(' ', '&nbsp;')
      end

      board = label_values.each_slice(builder.board_size)
        .map { |values| values.join('|') }
        .join('}|{')
      node_properties[:label] =
        "{{#{board}}|{#{optimal_action}}|{#{formatted_value}}}"
    end

    model.next_states(state, optimal_action).each do |next_state|
      probability = model.transition_probability(
        state, optimal_action, next_state
      )

      edge_properties = graph.add_edge(node_name(state), node_name(next_state))

      edge_properties[:taillabel] = format(' %.2f ', probability)
      edge_properties[:weight] = (100 * probability).round
      edge_properties[:color] = :grey
    end
  end
  graph
end

# # For a single file:
# input_stem = 'data/...'
# solver_params = { board_size: 4, max_exponent: 4, max_resolve_depth: 3 }
# model = Storage.read_model_file("#{input_stem}.json.bz2")
# solver = Storage.read_solver_file(model, "#{input_stem}.csv.bz2",
#   0.05)

Dir.glob(Storage::SOLVERS_GLOB).sort.each do |solver_pathname|
  solver_params = Storage.solver_params_from_pathname(solver_pathname)
  p solver_params
  next if Storage.estimate_solver_state_count(solver_params) > max_states

  builder, resolver = Storage.new_builder_from_model_params(solver_params)
  solver = Storage.read_solver(solver_params)

  graph = build_graph(builder, resolver, solver)

  output_pathname = Storage.graph_pathname(solver_params, '.dot')
  File.open(output_pathname, 'w') do |dot|
    dot.puts 'digraph {'
    dot.puts '  splines=spline;'
    dot.puts '  nodesep=1;' # horizontal spacing
    dot.puts '  ranksep=2;' # vertical spacing
    dot.puts '  node [fontname="Courier"];'
    dot.puts graph.to_dot.map { |line| "  #{line}" }.join("\n")
    dot.puts '}'
  end
  system "bzip2 --force #{output_pathname}"
end
